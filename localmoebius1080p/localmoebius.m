function [new_image] = localmoebius(image, inputs, outputs, center, radii,theta, type, size_final)
% INPUTS
% image(uint8 matrix) = image input;
% inputs(double matrix) = a 3x2 matrix with the initial positions x,y of 3
% points in the region [-pi,pi]x[-pi/2,pi/2], in the form [x_1 y_1; x_2 y_2;
% x_3 y_3];
% outputs(double matrix) = a 3x2 matrix with the final positions x,y of 3
% points without region restriction in R, in the form [nx_1 ny_1; nx_2 ny_2;
% nx_3 ny_3];
% center(double vector) = a vector with the Cx, Cy positions of the
% smoothing function, in the form [Cx Cy];
% radii(double vector) = a vector with the Rx, Ry radius of the smoothing
% function, in the form [Rx Ry];
% theta(double) = the value (in radians) for the counterclockwise rotation
% in the smoothing function;
% size_final(integer vector) = the final wanted resolution MxN pixels in the
% form [M N].
% -----
% OUTPUT
% newimage  = an uint8 matrix that can be read as an image with the
% respective projection trasformation.
% -----
% SYNTAX
% B = imagemoebius(A, inputs, outputs)
% Will do a transformation that sends the pixel points to new positions based 
% on the moebius transformation generated by the cross-ratio of
% <inputs>,<outputs> points and projects the final image on equirectangular
% domain without smoothing function;
% B = imagemoebius(A, inputs, outputs, center, radius, theta)
% Will do a transformation that sends the pixel points to new positions based 
% on the moebius transformation generated by the cross-ratio of
% <inputs>,<outputs> points and smooths the transformation with a 2D-Gaussian
% centered in <center(1)>, <center(2)>, with radius Rx = <radius(1)>, Ry =
% <radius(2)> with a counterclockwise rotation <theta>;
% B = imagemoebius(A, inputs, outputs, center, radius, theta, type)
% Will do a transformation that sends the pixel points to new positions based 
% on the moebius transformation generated by the cross-ratio of
% <inputs>,<outputs> points and smooths the transformation with a <type>
% smoothing function centered in <center(1)>, <center(2)>, with radius 
% Rx = <radius(1)>, Ry = <radius(2)> with a counterclockwise rotation <theta>;
% B = imagemoebius(A, inputs, outputs, center, radius, theta, type, size_final)
% Will do a transformation that sends the pixel points to new positions based 
% on the moebius transformation generated by the cross-ratio of
% <inputs>,<outputs> points and smooths the transformation with a <type>
% smoothing function centered in <center(1)>, <center(2)>, with radius 
% Rx = <radius(1)>, Ry = <radius(2)> with a counterclockwise rotation <theta> 
% and projects the final image using a projection on equirectangular domain
% with <size_final> resolution.
% ------------------------------------------------------------------------
% version 1.0
% ------------------------------------------------------------------------
% ------------------------------------------------------------------------
% ------------------------------------------------------------------------
% ------------------------------------------------------------------------
% 2017
% ------------------------------------------------------------------------

%uncatenate the colors of the image
R = double(image(:,:,1));
G = double(image(:,:,2));
B = double(image(:,:,3));
%obtain the size of the image
[nr nc]=size(R);
%Check the parameters
if nargin < 3
    error('Not suficient input values')
elseif nargin > 8
    error('Too many arguments')
elseif nargin == 3
    center = [0 0];
    radii = [inf inf];
    theta = 0;
    type = 'Gaussian';
    size_final = [nr nc];
elseif nargin == 6
    type = 'Gaussian';
    size_final = [nr nc];
elseif nargin == 7
    size_final = [nr nc];
elseif nargin == 8
    
else
    error('Wrong inputs')
end

%Define the domain
aa = linspace(-pi,pi,nc);
cc = linspace(pi/2,-pi/2,nr); 
[AA,CC]=meshgrid(aa,cc);
%Define the counter-domain
 
x = linspace(-pi,pi,size_final(1,2));  
y = linspace(pi/2,-pi/2,size_final(1,1)); 
[X,Y]=meshgrid(x,y);
 
%concatenate the inputs in a matrix
input_coord = cat(2, inputs, outputs);
if size(input_coord) ~= [3 4]
    error('Wrong entries for input and output points.')
end
N = 3;
%Transform the input points in sphere points
sphere_coord = zeros(3,6);
n = 1;
while n <= N
    sphere_coord(n,1) = cos(input_coord(n,2))*cos(input_coord(n,1));
    sphere_coord(n,2) = cos(input_coord(n,2))*sin(input_coord(n,1));
    sphere_coord(n,3) = sin(input_coord(n,2));
    sphere_coord(n,4) = cos(input_coord(n,4))*cos(input_coord(n,3));
    sphere_coord(n,5) = cos(input_coord(n,4))*sin(input_coord(n,3));
    sphere_coord(n,6) = sin(input_coord(n,4));
    n = n + 1;
end
%Projects the spheric input points onto stereografic plane
stereo_coord = zeros(3,4);
n = 1;
while n <= N
    stereo_coord(n,1) = 2*sphere_coord(n,2)/(sphere_coord(n,1) +1);
    stereo_coord(n,2) = 2*sphere_coord(n,3)/(sphere_coord(n,1) +1);
    stereo_coord(n,3) = 2*sphere_coord(n,5)/(sphere_coord(n,4) +1);
    stereo_coord(n,4) = 2*sphere_coord(n,6)/(sphere_coord(n,4) +1);
    n = n + 1;
end
%transform the stereographic input points onto complex numbers
complex_coord = zeros(3, 2);
n = 1;
while n <= N
    complex_coord(n,1) = stereo_coord(n,1) + stereo_coord(n,2)*1i;
    complex_coord(n,2) = stereo_coord(n,3) + stereo_coord(n,4)*1i;
    n = n + 1;
end
%Calculates the parameters of moebius transformation using a external
%function called crossmoebius
[a b c d] = crossmoebius(complex_coord(1,1), complex_coord(2,1), complex_coord(3,1),...
    complex_coord(1,2), complex_coord(2,2), complex_coord(3,2));
if abs(c) < 1e-10
    c = 1e-10 + 1e-10*1i;
end
%from final equirectangular projection to the sphere
x_sphere = cos(X).*cos(Y);
y_sphere = sin(X).*cos(Y);
z_sphere = sin(Y);
%From sphere to stereographic plane
X_C =(2*y_sphere)./(x_sphere + 1);
Y_C =(2*z_sphere)./(x_sphere + 1);
%From stereographic plane to complex numbers
Complex = X_C + Y_C*1i;
%inverse moebius transformation
Complex = Complex - a/c;
Complex = Complex*(-(c^2/(a*d - b*c)));
Complex = 1./Complex;
Complex = Complex - d/c;
%Returning to stereographic plane
X_C_n = real(Complex);
Y_C_n = imag(Complex);
%Fixing the mirrowing
r_polar = sqrt(X_C_n.^2 + Y_C_n.^2);
theta_polar = atan2(X_C_n,Y_C_n);
theta_polar = theta_polar + pi/2;
X_C_n = r_polar.*cos(theta_polar);
Y_C_n = r_polar.*sin(theta_polar);
 
%Return to the sphere
x_sphere2 = -(X_C_n.^2 + Y_C_n.^2 - 4)./(X_C_n.^2 + Y_C_n.^2 + 4); 
y_sphere2 = -(4*X_C_n)./(X_C_n.^2 + Y_C_n.^2 + 4); 
z_sphere2 = (4*Y_C_n)./(X_C_n.^2 + Y_C_n.^2 + 4);
 
%Return to the original equirectangular domain
U = atan2(y_sphere2, x_sphere2);
V = asin(z_sphere2);
 
%applying the smoothing function
Delta_X = U - X;
Delta_Y = V - Y;
[rows, columns] = size(X);
rot_matrix = [cos(-theta) -sin(-theta); sin(-theta) cos(-theta)]; 
switch type
    case 'Gaussian'
        new_DX = gaussian2d(X,Y,1,center(1),center(2),radii(1)/3,radii(2)/3,theta).*Delta_X;
        new_DY = gaussian2d(X,Y,1,center(1),center(2),radii(1)/3,radii(2)/3,theta).*Delta_Y;
    case 'Linear'
        pos_X = reshape(X,[1,rows*columns]) - center(1);
        pos_Y = reshape(Y,[1,rows*columns]) - center(2);
        result = rot_matrix*[pos_X; pos_Y];
        new_x = result(1,:);
        new_y = result(2,:);
        new_x = reshape(new_x, [rows,columns]);
        new_y = reshape(new_y, [rows,columns]);
        new_x = new_x./radii(1);
        new_y = new_y./radii(2);
        new_x = 1-min(1,abs(new_x));
        new_y = 1-min(1,abs(new_y));
        sp_2 = new_x.*new_y;
        new_DX = sp_2.*Delta_X;
        new_DY = sp_2.*Delta_Y;
    case 'Quadratic'
        pos_X = reshape(X,[1,rows*columns]) - center(1);
        pos_Y = reshape(Y,[1,rows*columns]) - center(2);
        result = rot_matrix*[pos_X; pos_Y];
        new_x = result(1,:);
        new_y = result(2,:);
        new_x = reshape(new_x, [rows,columns]);
        new_y = reshape(new_y, [rows,columns]);
        new_x = 1.5*new_x/radii(1);
        new_y = 1.5*new_y/radii(2);
        new_x = min(1.5, abs(new_x));
        new_y = min(1.5, abs(new_y));
        new_x = ceil(new_x-min(0.5,new_x)).*(9 + new_x.*(-12 +4.*new_x))/8 + ceil(max(0.5,new_x)-new_x).*(6 - 8.*new_x.*new_x)/8;
        new_y = ceil(new_y-min(0.5,new_y)).*(9 + new_y.*(-12 +4.*new_y))/8 + ceil(max(0.5,new_y)-new_y).*(6 - 8.*new_y.*new_y)/8;
        sp_2 = new_x.*new_y;
        new_DX = sp_2.*Delta_X;
        new_DY = sp_2.*Delta_Y;
    case 'Cubic'
        pos_X = reshape(X,[1,rows*columns]) - center(1);
        pos_Y = reshape(Y,[1,rows*columns]) - center(2);
        result = rot_matrix*[pos_X; pos_Y];
        new_x = result(1,:);
        new_y = result(2,:);
        new_x = reshape(new_x, [rows,columns]);
        new_y = reshape(new_y, [rows,columns]);
        new_x = 2*new_x/radii(1);
        new_y = 2*new_y/radii(2);
        new_x = min(2, abs(new_x));
        new_y = min(2, abs(new_y));
        new_x = ceil(max(1,new_x)-new_x).*(4 + new_x.*new_x.*(-6  + 3.*new_x))/6 + ceil(new_x-min(1,new_x)).*(8 + new_x.*(-12 + (6 - new_x).*new_x))/6;
        new_y = ceil(max(1,new_y)-new_y).*(4 + new_y.*new_y.*(-6  + 3.*new_y))/6 + ceil(new_y-min(1,new_y)).*(8 + new_y.*(-12 + (6 - new_y).*new_y))/6;
        sp_2 = new_x.*new_y;
        new_DX = sp_2.*Delta_X;
        new_DY = sp_2.*Delta_Y;
    case 'Zoom'
        pos_X = reshape(X,[1,rows*columns]) - center(1); 
        pos_Y = reshape(Y,[1,rows*columns]) - center(2);
        result = rot_matrix*[pos_X; pos_Y];
        new_x = result(1,:);
        new_y = result(2,:);
        new_x = reshape(new_x, [rows,columns]);
        new_y = reshape(new_y, [rows,columns]);
        new_x = 2*new_x/radii(1);
        new_y = 2*new_y/radii(2);
        new_x = min(2, abs(new_x));
        new_y = min(2, abs(new_y));
        new_x = ceil(max(1,new_x)-new_x) + ceil(new_x-min(1,new_x)).*(2-new_x);
        new_y = ceil(max(1,new_y)-new_y) + ceil(new_y-min(1,new_y)).*(2-new_y);
        sp_2 = new_x.*new_y;
        new_DX = sp_2.*Delta_X;
        new_DY = sp_2.*Delta_Y;
    case 'LineRect'
        pos_X = reshape(X,[1,rows*columns]) - center(1); 
        pos_Y = reshape(Y,[1,rows*columns]) - center(2);
        result = rot_matrix*[pos_X; pos_Y];
        new_x = result(1,:);
        new_y = result(2,:);
        new_x = reshape(new_x, [rows,columns]);
        new_y = reshape(new_y, [rows,columns]);
        new_x = 2*new_x/radii(1);
        new_y = 2*new_y/radii(2);
        new_x = min(2, abs(new_x));
        new_y = min(2, abs(new_y));
        new_x = ceil(max(1,new_x)-new_x) + ceil(new_x-min(1,new_x)).*(2-new_x);
        new_y = ceil(max(1,new_y)-new_y) + ceil(new_y-min(1,new_y)).*(2-new_y);
        sp_2 = new_x.*new_y;
        new_DX = 0;
        new_DY = sp_2.*Delta_Y;
end

U_final = X + new_DX;
V_final = Y + new_DY;

%Interpolate the points
r=(qinterp2(AA,CC,R,U_final,V_final,0));
g=(qinterp2(AA,CC,G,U_final,V_final,0));
b=(qinterp2(AA,CC,B,U_final,V_final,0));
%final image (concatenating matrix layers)
new_image = (uint8(cat(3,r,g,b)));
 
end